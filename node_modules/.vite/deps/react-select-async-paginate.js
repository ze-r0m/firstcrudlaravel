import {
  StateManagedSelect$1,
  components
} from "./chunk-OKJT4TM6.js";
import "./chunk-IFUEIYXT.js";
import "./chunk-KBUAZBQ3.js";
import "./chunk-X77HWGET.js";
import "./chunk-QMINRHT5.js";
import {
  require_jsx_runtime
} from "./chunk-K4QCH4XS.js";
import {
  require_react
} from "./chunk-QV6VW2LK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/@seznam/compose-react-refs/composeRefs.js
var require_composeRefs = __commonJS({
  "node_modules/@seznam/compose-react-refs/composeRefs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function composeRefs2() {
      var refs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
      }
      if (refs.length === 2) {
        return composeTwoRefs(refs[0], refs[1]) || null;
      }
      var composedRef = refs.slice(1).reduce(function(semiCombinedRef, refToInclude) {
        return composeTwoRefs(semiCombinedRef, refToInclude);
      }, refs[0]);
      return composedRef || null;
    }
    exports.default = composeRefs2;
    var composedRefCache = /* @__PURE__ */ new WeakMap();
    function composeTwoRefs(ref1, ref2) {
      if (ref1 && ref2) {
        var ref1Cache = composedRefCache.get(ref1) || /* @__PURE__ */ new WeakMap();
        composedRefCache.set(ref1, ref1Cache);
        var composedRef = ref1Cache.get(ref2) || function(instance) {
          updateRef(ref1, instance);
          updateRef(ref2, instance);
        };
        ref1Cache.set(ref2, composedRef);
        return composedRef;
      }
      if (!ref1) {
        return ref2;
      } else {
        return ref1;
      }
    }
    function updateRef(ref, instance) {
      if (typeof ref === "function") {
        ref(instance);
      } else {
        ref.current = instance;
      }
    }
  }
});

// node_modules/react-select-async-paginate/dist/esm/index.js
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/use-is-mounted-ref/dist/use-is-mounted-ref.es.js
var import_react = __toESM(require_react());
function useIsMountedRef() {
  var isMountedRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef;
}

// node_modules/@vtaits/use-lazy-ref/dist/use-lazy-ref.js
var import_react2 = __toESM(require_react());
var EMPTY_VALUE = Symbol("useLazyRef empty value");
var useLazyRef = (init) => {
  const resultRef = (0, import_react2.useRef)(EMPTY_VALUE);
  if (resultRef.current === EMPTY_VALUE) {
    resultRef.current = init();
  }
  return resultRef;
};

// node_modules/sleep-promise/build/esm.mjs
var e = setTimeout;
function t(t2, n2) {
  var u = n2.useCachedSetTimeout ? e : setTimeout;
  return new Promise(function(e2) {
    u(e2, t2);
  });
}
function n(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, u = n2.useCachedSetTimeout, r = t(e2, { useCachedSetTimeout: u });
  function o(e3) {
    return r.then(function() {
      return e3;
    });
  }
  return o.then = function() {
    return r.then.apply(r, arguments);
  }, o.catch = Promise.resolve().catch, o;
}
var esm_default = n;

// node_modules/react-select-async-paginate/dist/esm/index.js
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_compose_react_refs = __toESM(require_composeRefs());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var getInitialCache = (params) => ({
  isFirstLoad: true,
  options: [],
  hasMore: true,
  isLoading: false,
  additional: params.additional
});
var getInitialOptionsCache = ({
  options,
  defaultOptions,
  additional,
  defaultAdditional
}) => {
  const initialOptions = defaultOptions === true ? null : defaultOptions instanceof Array ? defaultOptions : options;
  if (initialOptions) {
    return {
      "": {
        isFirstLoad: false,
        isLoading: false,
        options: initialOptions,
        hasMore: true,
        additional: defaultAdditional || additional
      }
    };
  }
  return {};
};
var AVAILABLE_DELTA = 10;
var defaultShouldLoadMore = (scrollHeight, clientHeight, scrollTop) => {
  const bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;
  return bottomBorder < scrollTop;
};
var defaultReduceOptions = (prevOptions, loadedOptions) => [...prevOptions, ...loadedOptions];
var errorText = '[react-select-async-paginate] response of "loadOptions" should be an object with "options" prop, which contains array of options.';
var checkIsResponse = (response) => {
  if (!response) {
    return false;
  }
  const {
    options,
    hasMore
  } = response;
  if (!Array.isArray(options)) {
    return false;
  }
  if (typeof hasMore !== "boolean" && typeof hasMore !== "undefined") {
    return false;
  }
  return true;
};
var validateResponse = (response) => {
  if (!checkIsResponse(response)) {
    console.error(errorText, "Received:", response);
    throw new Error(errorText);
  }
  return true;
};
var requestOptions = async (caller, paramsRef, optionsCacheRef, debounceTimeout, setOptionsCache, reduceOptions) => {
  const currentInputValue = paramsRef.current.inputValue;
  const isCacheEmpty = !optionsCacheRef.current[currentInputValue];
  const currentOptions = isCacheEmpty ? getInitialCache(paramsRef.current) : optionsCacheRef.current[currentInputValue];
  if (currentOptions.isLoading || !currentOptions.hasMore) {
    return;
  }
  setOptionsCache((prevOptionsCache) => ({
    ...prevOptionsCache,
    [currentInputValue]: {
      ...currentOptions,
      isLoading: true
    }
  }));
  if (debounceTimeout > 0 && caller === "input-change") {
    await esm_default(debounceTimeout);
    const newInputValue = paramsRef.current.inputValue;
    if (currentInputValue !== newInputValue) {
      setOptionsCache((prevOptionsCache) => {
        if (isCacheEmpty) {
          const {
            [currentInputValue]: itemForDelete,
            ...restCache
          } = prevOptionsCache;
          return restCache;
        }
        return {
          ...prevOptionsCache,
          [currentInputValue]: {
            ...currentOptions,
            isLoading: false
          }
        };
      });
      return;
    }
  }
  let response;
  let hasError = false;
  try {
    const {
      loadOptions
    } = paramsRef.current;
    response = await loadOptions(
      currentInputValue,
      currentOptions.options,
      currentOptions.additional
    );
  } catch (e2) {
    hasError = true;
  }
  if (hasError) {
    setOptionsCache((prevOptionsCache) => ({
      ...prevOptionsCache,
      [currentInputValue]: {
        ...currentOptions,
        isLoading: false
      }
    }));
    return;
  }
  if (validateResponse(response)) {
    const {
      options,
      hasMore
    } = response;
    const newAdditional = response.hasOwnProperty("additional") ? response.additional : currentOptions.additional;
    setOptionsCache((prevOptionsCache) => ({
      ...prevOptionsCache,
      [currentInputValue]: {
        ...currentOptions,
        options: reduceOptions(currentOptions.options, options, newAdditional),
        hasMore: !!hasMore,
        isLoading: false,
        isFirstLoad: false,
        additional: newAdditional
      }
    }));
  }
};
var increaseStateId = (prevStateId) => prevStateId + 1;
var useAsyncPaginateBase = (params, deps = []) => {
  const {
    defaultOptions,
    loadOptionsOnMenuOpen = true,
    debounceTimeout = 0,
    inputValue,
    menuIsOpen,
    filterOption = null,
    reduceOptions = defaultReduceOptions,
    shouldLoadMore = defaultShouldLoadMore
  } = params;
  const isMountedRef = useIsMountedRef();
  const isInitRef = (0, import_react4.useRef)(true);
  const paramsRef = (0, import_react4.useRef)(params);
  paramsRef.current = params;
  const setStateId = (0, import_react4.useState)(0)[1];
  const optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));
  const callRequestOptions = (0, import_react4.useCallback)((caller) => {
    requestOptions(
      caller,
      paramsRef,
      optionsCacheRef,
      debounceTimeout,
      (reduceState) => {
        optionsCacheRef.current = reduceState(optionsCacheRef.current);
        if (isMountedRef.current) {
          setStateId(increaseStateId);
        }
      },
      reduceOptions
    );
  }, [debounceTimeout]);
  const handleScrolledToBottom = (0, import_react4.useCallback)(() => {
    const currentInputValue = paramsRef.current.inputValue;
    const currentOptions2 = optionsCacheRef.current[currentInputValue];
    if (currentOptions2) {
      callRequestOptions("menu-scroll");
    }
  }, [callRequestOptions]);
  (0, import_react4.useEffect)(() => {
    if (isInitRef.current) {
      isInitRef.current = false;
    } else {
      optionsCacheRef.current = {};
      setStateId(increaseStateId);
    }
    if (defaultOptions === true) {
      callRequestOptions("autoload");
    }
  }, deps);
  (0, import_react4.useEffect)(() => {
    if (menuIsOpen && !optionsCacheRef.current[inputValue]) {
      callRequestOptions("input-change");
    }
  }, [inputValue]);
  (0, import_react4.useEffect)(() => {
    if (menuIsOpen && !optionsCacheRef.current[""] && loadOptionsOnMenuOpen) {
      callRequestOptions("menu-toggle");
    }
  }, [menuIsOpen]);
  const currentOptions = optionsCacheRef.current[inputValue] || getInitialCache(params);
  return {
    handleScrolledToBottom,
    shouldLoadMore,
    filterOption,
    isLoading: currentOptions.isLoading,
    isFirstLoad: currentOptions.isFirstLoad,
    options: currentOptions.options
  };
};
var useAsyncPaginate = (params, deps = []) => {
  const {
    inputValue: inputValueParam,
    menuIsOpen: menuIsOpenParam,
    defaultInputValue: defaultInputValueParam,
    defaultMenuIsOpen: defaultMenuIsOpenParam,
    onInputChange: onInputChangeParam,
    onMenuClose: onMenuCloseParam,
    onMenuOpen: onMenuOpenParam
  } = params;
  const [inputValueState, setInputValue] = (0, import_react3.useState)(
    defaultInputValueParam || ""
  );
  const [menuIsOpenState, setMenuIsOpen] = (0, import_react3.useState)(
    !!defaultMenuIsOpenParam
  );
  const inputValue = typeof inputValueParam === "string" ? inputValueParam : inputValueState;
  const menuIsOpen = typeof menuIsOpenParam === "boolean" ? menuIsOpenParam : menuIsOpenState;
  const onInputChange = (0, import_react3.useCallback)((nextInputValue, actionMeta) => {
    if (onInputChangeParam) {
      onInputChangeParam(nextInputValue, actionMeta);
    }
    setInputValue(nextInputValue);
  }, [onInputChangeParam]);
  const onMenuClose = (0, import_react3.useCallback)(() => {
    if (onMenuCloseParam) {
      onMenuCloseParam();
    }
    setMenuIsOpen(false);
  }, [onMenuCloseParam]);
  const onMenuOpen = (0, import_react3.useCallback)(() => {
    if (onMenuOpenParam) {
      onMenuOpenParam();
    }
    setMenuIsOpen(true);
  }, [onMenuOpenParam]);
  const baseResult = useAsyncPaginateBase(
    {
      ...params,
      inputValue,
      menuIsOpen
    },
    deps
  );
  return {
    ...baseResult,
    inputValue,
    menuIsOpen,
    onInputChange,
    onMenuClose,
    onMenuOpen
  };
};
var CHECK_TIMEOUT = 300;
function wrapMenuList(MenuList2) {
  function WrappedMenuList(props) {
    const {
      selectProps,
      innerRef
    } = props;
    const {
      handleScrolledToBottom,
      shouldLoadMore
    } = selectProps;
    const checkTimeoutRef = (0, import_react6.useRef)();
    const menuListRef = (0, import_react6.useRef)(null);
    const shouldHandle = (0, import_react6.useCallback)(() => {
      const el = menuListRef.current;
      if (!el) {
        return false;
      }
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = el;
      return shouldLoadMore(scrollHeight, clientHeight, scrollTop);
    }, [shouldLoadMore]);
    const checkAndHandle = (0, import_react6.useCallback)(() => {
      if (shouldHandle()) {
        if (handleScrolledToBottom) {
          handleScrolledToBottom();
        }
      }
    }, [shouldHandle, handleScrolledToBottom]);
    const setCheckAndHandleTimeout = (0, import_react6.useCallback)(() => {
      checkAndHandle();
      checkTimeoutRef.current = setTimeout(setCheckAndHandleTimeout, CHECK_TIMEOUT);
    }, [checkAndHandle]);
    (0, import_react6.useEffect)(() => {
      setCheckAndHandleTimeout();
      return () => {
        if (checkTimeoutRef.current) {
          clearTimeout(checkTimeoutRef.current);
        }
      };
    }, []);
    return (0, import_jsx_runtime.jsx)(
      MenuList2,
      {
        ...props,
        innerRef: (0, import_compose_react_refs.default)(innerRef, menuListRef)
      }
    );
  }
  return WrappedMenuList;
}
var MenuList = wrapMenuList(components.MenuList);
var useComponents = (components2) => (0, import_react5.useMemo)(() => ({
  MenuList,
  ...components2
}), [components2]);
var defaultCacheUniqs = [];
var defaultComponents2 = {};
function withAsyncPaginate(SelectComponent) {
  function WithAsyncPaginate(props) {
    const {
      components: components2 = defaultComponents2,
      selectRef = void 0,
      isLoading: isLoadingProp,
      cacheUniqs = defaultCacheUniqs,
      ...rest
    } = props;
    const asyncPaginateProps = useAsyncPaginate(
      rest,
      cacheUniqs
    );
    const processedComponents = useComponents(components2);
    const isLoading = typeof isLoadingProp === "boolean" ? isLoadingProp : asyncPaginateProps.isLoading;
    return (0, import_jsx_runtime2.jsx)(
      SelectComponent,
      {
        ...props,
        ...asyncPaginateProps,
        isLoading,
        components: processedComponents,
        ref: selectRef
      }
    );
  }
  return WithAsyncPaginate;
}
var checkGroup = (group) => {
  if (!group) {
    return false;
  }
  const {
    label,
    options
  } = group;
  if (typeof label !== "string" && typeof label !== "undefined") {
    return false;
  }
  if (!Array.isArray(options)) {
    return false;
  }
  return true;
};
var reduceGroupedOptions = (prevOptions, loadedOptions) => {
  const res = prevOptions.slice();
  const mapLabelToIndex = {};
  let prevOptionsIndex = 0;
  const prevOptionsLength = prevOptions.length;
  loadedOptions.forEach((optionOrGroup) => {
    const group = checkGroup(optionOrGroup) ? optionOrGroup : {
      options: [optionOrGroup]
    };
    const {
      label = ""
    } = group;
    let groupIndex = mapLabelToIndex[label];
    if (typeof groupIndex !== "number") {
      for (; prevOptionsIndex < prevOptionsLength && typeof mapLabelToIndex[label] !== "number"; ++prevOptionsIndex) {
        const prevGroup = prevOptions[prevOptionsIndex];
        if (checkGroup(prevGroup)) {
          mapLabelToIndex[prevGroup.label || ""] = prevOptionsIndex;
        }
      }
      groupIndex = mapLabelToIndex[label];
    }
    if (typeof groupIndex !== "number") {
      mapLabelToIndex[label] = res.length;
      res.push(group);
      return;
    }
    res[groupIndex] = {
      ...res[groupIndex],
      options: [...res[groupIndex].options, ...group.options]
    };
  });
  return res;
};
var AsyncPaginate = withAsyncPaginate(StateManagedSelect$1);
export {
  AsyncPaginate,
  checkIsResponse,
  reduceGroupedOptions,
  useAsyncPaginate,
  useAsyncPaginateBase,
  useComponents,
  validateResponse,
  withAsyncPaginate,
  wrapMenuList
};
//# sourceMappingURL=react-select-async-paginate.js.map
