"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Translate = void 0;
const deep_object_diff_1 = require("deep-object-diff");
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const just_extend_1 = __importDefault(require("just-extend"));
const path_1 = __importDefault(require("path"));
const cli_1 = require("./cli");
const util_1 = require("./util");
class Translate {
    constructor() {
        this.fileForTranslation = {};
        this.saveTo = '';
        this.skippedWords = [];
        this.translate = async () => {
            if (cli_1.argv.filePath && cli_1.argv.dirPath) {
                throw new Error('You should only provide a single file or a directory.');
            }
            if (!cli_1.argv.filePath && !cli_1.argv.dirPath) {
                throw new Error('You must provide a single file or a directory.');
            }
            if (cli_1.argv.dirPath) {
                await this.translateFiles(cli_1.argv.dirPath);
            }
            if (cli_1.argv.filePath) {
                await this.translateFile(cli_1.argv.filePath);
            }
        };
        this.translateFiles = async (dirPath) => {
            console.log('Finding files for translation...');
            const filePaths = (0, glob_1.globSync)(`${dirPath}/**/${cli_1.argv.from}.json`, {
                ignore: [`${dirPath}/**/node_modules/**`, `${dirPath}/**/dist/**`],
            });
            if (filePaths.length === 0) {
                throw new Error(`0 files found for translation in ${dirPath}`);
            }
            console.log(`${filePaths.length} files found.`);
            for (const filePath of filePaths) {
                this.skippedWords = [];
                await this.translateFile(filePath);
            }
        };
        this.translateFile = async (filePath) => {
            try {
                this.fileForTranslation = JSON.parse(fs_1.default.readFileSync(filePath, 'utf-8'));
                this.saveTo = path_1.default.join(filePath.substring(0, filePath.lastIndexOf('/')), `${cli_1.argv.to}.json`);
                if (cli_1.argv.override || !fs_1.default.existsSync(this.saveTo)) {
                    await this.translationDoesNotExists();
                }
                else {
                    await this.translationAlreadyExists();
                }
            }
            catch (e) {
                console.log(`${e.message} at: ${filePath}`);
            }
        };
        this.translationDoesNotExists = async () => {
            if (Object.keys(this.fileForTranslation).length === 0) {
                console.log(`Nothing to translate, file is empty: ${this.saveTo}`);
                return;
            }
            const valuesForTranslation = this.getValuesForTranslation(this.fileForTranslation);
            await this.translateValues(valuesForTranslation, this.fileForTranslation);
        };
        this.translationAlreadyExists = async () => {
            try {
                const existingTranslation = JSON.parse(fs_1.default.readFileSync(this.saveTo, 'utf-8'));
                this.deleteIfNeeded(existingTranslation);
                await this.translateIfNeeded(existingTranslation);
            }
            catch (e) {
                console.log(`${e.message} at: ${this.saveTo}`);
            }
        };
        this.deleteIfNeeded = (existingTranslation) => {
            const diffForDeletion = (0, deep_object_diff_1.deletedDiff)(existingTranslation, this.fileForTranslation);
            if (Object.keys(diffForDeletion).length !== 0) {
                const content = (0, just_extend_1.default)(true, existingTranslation, diffForDeletion);
                this.writeToFile(content, `Unnecessary lines deleted for: ${this.saveTo}`);
            }
        };
        this.translateIfNeeded = async (existingTranslation) => {
            const diffForTranslation = (0, deep_object_diff_1.addedDiff)(existingTranslation, this.fileForTranslation);
            if (Object.keys(diffForTranslation).length === 0) {
                console.log(`Everything already translated for: ${this.saveTo}`);
                return;
            }
            const valuesForTranslation = this.getValuesForTranslation(diffForTranslation);
            await this.translateValues(valuesForTranslation, diffForTranslation);
        };
        this.getValuesForTranslation = (objectBeforeTranslation) => {
            let values = [];
            (function findValues(json) {
                Object.values(json).forEach((value) => {
                    if (typeof value === 'object') {
                        findValues(value);
                    }
                    else {
                        values.push(value);
                    }
                });
            })(objectBeforeTranslation);
            values = values.map((value) => this.skipWords(value));
            return values;
        };
        this.translateValues = async (valuesForTranslation, objectBeforeTranslation) => {
            try {
                if (valuesForTranslation.length > cli_1.argv.maxLinesPerRequest) {
                    const splitted = this.splitValuesForTranslation(valuesForTranslation);
                    const promises = splitted.map((values) => this.callTranslateAPI(values));
                    const responses = await Promise.all(promises);
                    const translated = responses.join(Translate.sentenceDelimiter);
                    this.saveTranslation(this.cleanUpTranslations(translated), objectBeforeTranslation);
                }
                else {
                    const translated = await this.callTranslateAPI(valuesForTranslation);
                    this.saveTranslation(this.cleanUpTranslations(translated), objectBeforeTranslation);
                }
            }
            catch (error) {
                this.printError(error);
            }
        };
        this.splitValuesForTranslation = (valuesForTranslation) => {
            const resultArrays = [];
            for (let i = 0; i < valuesForTranslation.length; i += cli_1.argv.maxLinesPerRequest) {
                const chunk = valuesForTranslation.slice(i, i + cli_1.argv.maxLinesPerRequest);
                resultArrays.push(chunk);
            }
            return resultArrays;
        };
        this.cleanUpTranslations = (value) => {
            // This is needed because of this weird bug:
            // https://github.com/while1618/i18n-auto-translation/issues/12
            const patterns = [
                ['#__ #', '#__#'],
                ['# __#', '#__#'],
                ['# __ #', '#__#'],
            ];
            return (0, util_1.replaceAll)(value, patterns);
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.printError = (error) => {
            const errorFilePath = this.saveTo.replace(`${cli_1.argv.to}.json`, `${cli_1.argv.from}.json`);
            console.error(`Request error for file: ${errorFilePath}`);
            console.log(`Status Code: ${error?.response?.status ?? error?.response?.statusCode}`);
            console.log(`Status Text: ${error?.response?.statusText ?? error?.response?.statusMessage}`);
            console.log(`Data: ${JSON.stringify(error?.response?.data) ?? JSON.stringify(error?.errors[0].message)}`);
        };
        this.saveTranslation = (translations, objectBeforeTranslation) => {
            let objectAfterTranslation = this.createTranslatedObject(translations.split(Translate.sentenceDelimiter.trim()), objectBeforeTranslation);
            if (fs_1.default.existsSync(this.saveTo) && !cli_1.argv.override) {
                const existingTranslation = JSON.parse(fs_1.default.readFileSync(this.saveTo, 'utf-8'));
                objectAfterTranslation = (0, just_extend_1.default)(true, existingTranslation, objectAfterTranslation);
                objectAfterTranslation = this.reorderJSONKeys(this.fileForTranslation, objectAfterTranslation);
            }
            this.writeToFile(objectAfterTranslation, this.getSaveMessage());
        };
        this.createTranslatedObject = (translations, objectBeforeTranslation) => {
            translations = translations.map((value) => this.returnSkippedWords(value));
            const translatedObject = { ...objectBeforeTranslation };
            let index = 0;
            (function addTranslations(json) {
                Object.keys(json).forEach((key) => {
                    if (typeof json[key] === 'object') {
                        addTranslations(json[key]);
                    }
                    else {
                        json[key] = translations[index++]?.trim();
                    }
                });
            })(translatedObject);
            return translatedObject;
        };
        this.getSaveMessage = () => {
            return fs_1.default.existsSync(this.saveTo) && !cli_1.argv.override
                ? `File updated: ${this.saveTo}`
                : `File saved: ${this.saveTo}`;
        };
        this.writeToFile = (content, message) => {
            try {
                fs_1.default.writeFileSync(this.saveTo, JSON.stringify(content, null, cli_1.argv.spaces));
                console.log(message);
            }
            catch (e) {
                console.log(e.message);
            }
        };
    }
    skipWords(value) {
        return value.replace(Translate.skipWordRegex, (match) => {
            this.skippedWords.push(match.trim());
            return `{{${this.skippedWords.length - 1}}}`;
        });
    }
    returnSkippedWords(value) {
        return value.replace(Translate.skipWordRegex, () => `${this.skippedWords.shift()}`);
    }
    reorderJSONKeys(reference, target) {
        const reordered = {};
        Object.keys(reference).forEach((key) => {
            if (key in target) {
                const refValue = reference[key];
                const targetValue = target[key];
                if (typeof refValue === 'object' && typeof targetValue === 'object') {
                    reordered[key] = this.reorderJSONKeys(refValue, targetValue);
                }
                else {
                    reordered[key] = targetValue;
                }
            }
        });
        return reordered;
    }
}
exports.Translate = Translate;
Translate.sentenceDelimiter = '\n#__#\n';
Translate.skipWordRegex = /({{([^{}]+)}}|<([^<>]+)>|<\/([^<>]+)>|\{([^{}]+)\})/g;
//# sourceMappingURL=translate.js.map